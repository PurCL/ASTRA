{
    "unsafe-cloudpickle-load": {
        "ruleId": "unsafe-cloudpickle-load",
        "version": "1.0",
        "name": "Unsafe Cloudpickle Load",
        "shortDescription": "Pickling issues on Cloudpickle Load.",
        "longDescription": "Detects the usage of cloudpickle.load for deserializing data from a file, which can lead to insecure deserialization vulnerabilities.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "deserialization",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/unsafe-cloudpickle-load@v1.0",
        "cwes": [
            502
        ],
        "category": "security",
        "snippets": []
    },
    "sns-unauthenticated-unsubscribe": {
        "ruleId": "sns-unauthenticated-unsubscribe",
        "version": "1.0",
        "name": "Unauthenticated Amazon SNS unsubscribe requests might succeed",
        "shortDescription": "Failing to set the `AuthenticateOnUnsubscribe` flag to `True` when confirming an SNS subscription can lead to unauthenticated cancellations.",
        "longDescription": "Failing to set the `AuthenticateOnUnsubscribe` flag to `True` when confirming an SNS subscription causes all unsubscribe requests to succeed, even if they are unauthenticated. Consider setting this flag to `True`.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "amazon-sns",
            "aws-python-sdk",
            "data-integrity"
        ],
        "ruleManifestId": "python/sns-unauthenticated-unsubscribe@v1.0",
        "cwes": [
            19
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def authenticate_on_subscribe_noncompliant(self, event) -> None:\n    import boto3\n    subscriptions_failed = 0\n    for record in event[\"Records\"]:\n        message = record[\"body\"]\n        if message[\"Type\"] == \"SubscriptionConfirmation\":\n            try:\n                topic_arn = message[\"TopicArn\"]\n                token = message[\"Token\"]\n                sns_client = boto3.client(\"sns\",\n                                          region_name=topic_arn.split(\":\")[3])\n                # Noncompliant: fails to set the 'AuthenticateOnUnsubscribe'\n                # argument to 'True' while confirming an SNS subscription.\n                sns_client.confirm_subscription(TopicArn=topic_arn,\n                                                Token=token)\n            except Exception:\n                subscriptions_failed += 1"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def authenticate_on_subscribe_compliant(self, event) -> None:\n    import boto3\n    subscriptions_failed = 0\n    for record in event[\"Records\"]:\n        message = record[\"body\"]\n        if message[\"Type\"] == \"SubscriptionConfirmation\":\n            try:\n                topic_arn = message[\"TopicArn\"]\n                token = message[\"Token\"]\n                sns_client = boto3.client(\"sns\",\n                                          region_name=topic_arn.split(\":\")[3])\n                # Compliant: sets the 'AuthenticateOnUnsubscribe' argument to\n                # 'True' while confirming an SNS subscription.\n                sns_client.confirm_subscription(\n                    TopicArn=topic_arn,\n                    Token=token,\n                    AuthenticateOnUnsubscribe='True')\n            except Exception:\n                subscriptions_failed += 1"
            }
        ]
    },
    "public-method-parameter-validation": {
        "ruleId": "public-method-parameter-validation",
        "version": "1.0",
        "name": "Public method parameter validation",
        "shortDescription": "Public method parameters should be validated for nullness, unexpected values, and malicious values.",
        "longDescription": "Public method parameters should be validated for nullness, unexpected values, and malicious values. Invalid or malicious input can compromise the system's safety.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "null-check",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/public-method-parameter-validation@v1.0",
        "cwes": [
            20
        ],
        "category": "security",
        "snippets": []
    },
    "mutually-exclusive-calls-found": {
        "ruleId": "mutually-exclusive-calls-found",
        "version": "1.0",
        "name": "Mutually exclusive call",
        "shortDescription": "Calls to mutually exclusive methods were found in the code.",
        "longDescription": "Calls to mutually exclusive methods were found in the code. This could indicate a bug or a deeper problem.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "security-context"
        ],
        "ruleManifestId": "python/mutually-exclusive-calls-found@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def get_metrics_noncompliant() -> None:\n    import boto3\n    client = boto3.client('cloudwatch', region_name='eu-west-1')\n    datapoints = client.get_metric_statistics(\n        Namespace='CloudWatchSdkTest',\n        MetricName='PythonBotoTestMetric',\n        Dimensions=[\n            {\n                'Name': 'DimensionName',\n                'Value': 'DimensionValue'\n            },\n        ],\n        EndTime=datetime.datetime.now(datetime.timezone.utc),\n        StartTime=EndTime - datetime.timedelta(days=1),\n        Period=300,\n        # Noncompliant: calls mutually exclusive methods.\n        Statistics=[\n            'SampleCount', 'Average', 'Sum', 'Minimum', 'Maximum'\n        ],\n        ExtendedStatistics=[\n            'p70'\n        ]\n    )"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def get_metrics_compliant() -> None:\n    import boto3\n    client = boto3.client('cloudwatch', region_name='eu-west-1')\n    datapoints = client.get_metric_statistics(\n        Namespace='CloudWatchSdkTest',\n        MetricName='PythonBotoTestMetric',\n        Dimensions=[\n            {\n                'Name': 'DimensionName',\n                'Value': 'DimensionValue'\n            },\n        ],\n        EndTime=datetime.datetime.now(datetime.timezone.utc),\n        StartTime=EndTime - datetime.timedelta(days=1),\n        Period=300,\n        # Compliant: avoid calling mutually exclusive methods.\n        ExtendedStatistics=[\n            'p99',\n            'p100'\n        ]\n    )"
            }
        ]
    },
    "hardcoded-credentials": {
        "ruleId": "hardcoded-credentials",
        "version": "1.0",
        "name": "Hardcoded credentials",
        "shortDescription": "Credentials, such as passwords and access keys, should not be hardcoded in source code.",
        "longDescription": "Access credentials, such as passwords and access keys, should not be hardcoded in source code. Hardcoding credentials may cause leaks even after removing them. This is because version control systems might retain older versions of the code. Credentials should be stored securely and obtained from the runtime environment.",
        "severity": "Critical",
        "language": "Python",
        "tags": [
            "secrets",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/hardcoded-credentials@v1.0",
        "cwes": [
            798
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def create_session_noncompliant():\n    import boto3\n    # Noncompliant: uses hardcoded secret access key.\n    sample_key = \"AjWnyxxxxx45xxxxZxxxX7ZQxxxxYxxx1xYxxxxx\"\n    boto3.session.Session(aws_secret_access_key=sample_key)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def create_session_compliant():\n    import boto3\n    import os\n    # Compliant: uses environment variable for secret access key.\n    sample_key = os.environ.get(\"AWS_SECRET_ACCESS_KEY\")\n    boto3.session.Session(aws_secret_access_key=sample_key)"
            }
        ]
    },
    "s3-partial-encrypt-cdk": {
        "ruleId": "s3-partial-encrypt-cdk",
        "version": "1.0",
        "name": "S3 partial encrypt CDK",
        "shortDescription": "An unencrypted bucket could lead to sensitive data exposure.",
        "longDescription": "Failing to encrypt a bucket could lead to sensitive data being exposed to unauthorized users, consider adding `S3_MANAGED` of `KMS_MANAGED` encryption while creating a bucket.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk"
        ],
        "ruleManifestId": "python/s3-partial-encrypt-cdk@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": []
    },
    "unrestricted-file-upload": {
        "ruleId": "unrestricted-file-upload",
        "version": "1.0",
        "name": "Unrestricted upload of dangerous file type",
        "shortDescription": "Insufficiently restrictive file uploads can lead to inadvertently running malicious code.",
        "longDescription": "Insufficiently restricted file uploads can allow a file to be uploaded that runs malicious code. For example, a website that doesn't check the file extension of an image   can be exploited by uploading a script with an extension, such as `.php` or `.asp`,   that can be run on the server.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/unrestricted-file-upload@v1.0",
        "cwes": [
            434
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef file_upload_non_compliant():\n    import os\n    from flask import request\n    upload_file = request.files['file']\n    # Noncompliant: the uploaded file can have any extension.\n    upload_file.save(os.path.join('/path/to/the/uploads',\n                                  upload_file.filename))"
            },
            {
                "type": "COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef file_upload_compliant():\n    import os\n    from flask import request\n    extensions = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n    upload_file = request.files['file']\n    # Compliant: the uploaded file must have one of the allowed extensions.\n    if '.' in upload_file.filename and \\\n            upload_file.filename.split('.')[-1] in extensions:\n        upload_file.save(os.path.join('/path/to/the/uploads',\n                                      upload_file.filename))"
            }
        ]
    },
    "path-traversal": {
        "ruleId": "path-traversal",
        "version": "1.0",
        "name": "Path traversal",
        "shortDescription": "Constructing path names with unsanitized user input can lead to path traversal attacks (for example, `../../..`) that allow an attacker access to file system resources.",
        "longDescription": "Constructing path names with unsanitized user input can lead to path traversal attacks (for example, `../../..`) that allow an attacker access to file system resources.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/path-traversal@v1.0",
        "cwes": [
            22
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def verify_file_path_noncompliant():\n    from flask import request\n    file_path = request.args[\"file\"]\n    # Noncompliant: user input file path is not sanitized.\n    file = open(file_path)\n    file.close()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def verify_file_path_compliant():\n    from flask import request\n    base_path = \"/var/data/images/\"\n    file_path = request.args[\"file\"]\n    allowed_path = [\"example_path1\", \"example_path2\"]\n    # Compliant: user input file path is sanitized.\n    if file_path in allowed_path:\n        file = open(base_path + file_path)\n        file.close()"
            }
        ]
    },
    "resource-management-errors-cdk": {
        "ruleId": "resource-management-errors-cdk",
        "version": "1.0",
        "name": "Resource management errors cdk",
        "shortDescription": "Software system fails to properly track or release resources during its operation. This can lead to resource leaks.",
        "longDescription": "Proper resource management is important for robust, secure applications that maintain functionality over long periods of operation.From a security perspective, exhausted resources can enable denial of service attacks and other issues if safety checks start failing.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk",
            "efficiency"
        ],
        "ruleManifestId": "python/resource-management-errors-cdk@v1.0",
        "cwes": [
            399
        ],
        "category": "security",
        "snippets": []
    },
    "aws-missing-encryption-cdk": {
        "ruleId": "aws-missing-encryption-cdk",
        "version": "1.0",
        "name": "AWS missing encryption CDK",
        "shortDescription": "The AWS resource is missing appropriate encryption.",
        "longDescription": "Encryption ensure that the data is safe and is not sensitive to leakage. Ensure appropriate encryption strategies are used to prevent exposure of such sensitive data.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "aws-cdk"
        ],
        "ruleManifestId": "python/aws-missing-encryption-cdk@v1.0",
        "cwes": [
            311
        ],
        "category": "security",
        "snippets": []
    },
    "insecure-cryptography": {
        "ruleId": "insecure-cryptography",
        "version": "1.0",
        "name": "Insecure cryptography",
        "shortDescription": "Weak, broken, or misconfigured cryptography can lead to security vulnerabilities.",
        "longDescription": "Misuse of cryptography-related APIs can create security vulnerabilities. This includes algorithms with known weaknesses, certain padding modes, lack of integrity checks, insufficiently large key sizes, and insecure combinations of the aforementioned.",
        "severity": "Critical",
        "language": "Python",
        "tags": [
            "cryptography",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-cryptography@v1.0",
        "cwes": [
            327
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def cryptography_noncompliant():\n    from cryptography.hazmat.primitives import hashes, hmac\n    import secrets\n    # Noncompliant: keysize too small for this algorithm.\n    key = secrets.token_bytes(12)\n    hash_key = hmac.HMAC(key, algorithm=hashes.SHA512_224())"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def cryptography_compliant():\n    from cryptography.hazmat.primitives import hashes, hmac\n    import secrets\n    # Compliant: keysize sufficient for this algorithm.\n    key = secrets.token_bytes(48)\n    hash_key = hmac.HMAC(key, algorithm=hashes.SHA512_224())"
            }
        ]
    },
    "open-redirect": {
        "ruleId": "open-redirect",
        "version": "1.0",
        "name": "URL redirection to untrusted site",
        "shortDescription": "User-controlled input that specifies a link to an external site could lead to phishing attacks and allow user credentials to be stolen.",
        "longDescription": "An HTTP parameter could contain a URL value and cause the web application to redirect the request to the specified URL. By modifying the URL value to a malicious site, an attacker could successfully launch a phishing attack and steal user credentials.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "top25-cwes",
            "owasp-top10"
        ],
        "ruleManifestId": "python/open-redirect@v1.0",
        "cwes": [
            601
        ],
        "category": "security",
        "snippets": []
    },
    "insecure-cors-policy": {
        "ruleId": "insecure-cors-policy",
        "version": "1.0",
        "name": "Insecure CORS policy",
        "shortDescription": "Cross-Origin Resource Sharing policies that are too permissive may lead to security vulnerabilities.",
        "longDescription": "The same-origin policy prevents Web application front-ends from loading resources that come from a different domain, protocol, or Cross-Origin Resource Sharing (CORS) policies can be used to relax this restriction. CORS policies that are too permissive may lead to loading content from untrusted or malicious sources.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "configuration",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-cors-policy@v1.0",
        "cwes": [
            942
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "from flask import app, request\nfrom flask import Flask\nfrom flask_cors import CORS\n\n\napp = Flask(__name__)\n# Noncompliant: the send_wildcard is set to allow any domain.\nCORS(app, send_wildcard=True)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "from flask import app, request\nfrom flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n# Compliant: the send_wildcard is set to allow only a specific list of\n# trusted domains.\nCORS(app, send_wildcard=False)"
            }
        ]
    },
    "log-injection": {
        "ruleId": "log-injection",
        "version": "1.0",
        "name": "Log injection",
        "shortDescription": "Using untrusted inputs in a log statement can enable attackers to break the log's format, forge log entries, and bypass log monitors.",
        "longDescription": "User-provided inputs must be sanitized before they are logged. An attacker can use unsanitized input to break a log's integrity, forge log entries, or bypass log monitors.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "data-integrity",
            "injection",
            "owasp-top10"
        ],
        "ruleManifestId": "python/log-injection@v1.0",
        "cwes": [
            117,
            93
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def logging_noncompliant():\n    filename = input(\"Enter a filename: \")\n    # Noncompliant: unsanitized input is logged.\n    logger.info(\"Processing %s\", filename)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def logging_compliant():\n    filename = input(\"Enter a filename: \")\n    if filename.isalnum():\n        # Compliant: input is validated before logging.\n        logger.info(\"Processing %s\", filename)"
            }
        ]
    },
    "process-spawning-with-main-module": {
        "ruleId": "process-spawning-with-main-module",
        "version": "1.0",
        "name": "Spawning a process without main module",
        "shortDescription": "Using the `spawn` or `forkserver` start method without importing the main module might lead to unexpected behavior (for example, it might cause a `RuntimeError`).",
        "longDescription": "Using the `spawn` or `forkserver` start method without importing the main module might lead to unexpected behavior (for example, it might cause a `RuntimeError`). Consider using if `__name__ == '__main__'` to safely import the main module and then run the function.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "availability",
            "security-context",
            "subprocess"
        ],
        "ruleManifestId": "python/process-spawning-with-main-module@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": []
    },
    "socket-connection-timeout": {
        "ruleId": "socket-connection-timeout",
        "version": "1.0",
        "name": "Socket connection timeout",
        "shortDescription": "Not setting the connection timeout parameter can cause a blocking socket connection.",
        "longDescription": "A new Python socket by default doesn't have a timeout. Its timeout defaults to None. Not setting the connection timeout parameter can result in blocking socket mode. In blocking mode, operations block until complete or the system returns an error.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "availability",
            "networking",
            "resource-leak",
            "security-context"
        ],
        "ruleManifestId": "python/socket-connection-timeout@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def create_socket_noncompliant(samplehost, sampleport, samplebuffersize):\n    import socket\n    # Noncompliant: socket timeout is not set.\n    socket = socket.create_connection((samplehost, sampleport))\n    try:\n        print(socket.recv(samplebuffersize))\n    finally:\n        socket.close()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def create_socket_compliant(samplehost, sampleport, samplebuffersize):\n    import socket\n    # Compliant: socket timeout is set.\n    socket = socket.create_connection((samplehost, sampleport), timeout=10)\n    try:\n        print(socket.recv(samplebuffersize))\n    finally:\n        socket.close()"
            }
        ]
    },
    "not-recommended-apis": {
        "ruleId": "not-recommended-apis",
        "version": "1.0",
        "name": "Usage of an API that is not recommended",
        "shortDescription": "APIs that are not recommended were found.",
        "longDescription": "APIs that are not recommended were found. This could indicate a deeper problem in the code.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "security-context"
        ],
        "ruleManifestId": "python/not-recommended-apis@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "import xml.sax\n\n\nclass ContentHandler(xml.sax.ContentHandler):\n    def __init__(self):\n        xml.sax.ContentHandler.__init__(self)\n\n    def start_element(self, name, attributes):\n        print('start:', name)\n\n    def end_element(self, name):\n        print('end:', name)\n\n    def characters(self, characters):\n        print('characters:', characters)\n\n\ndef recommended_apis_noncompliant():\n    xml_string = \"<body>XML_STRING</body>\"\n\n    # Noncompliant: uses xml.sax which is an unrecommended API.\n    xml.sax.parseString(xml_string, ContentHandler())\n\n\nif __name__ == \"__main__\":\n    recommended_apis_noncompliant()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "import xml\nimport defusedxml.sax\n\n\nclass ContentHandler(xml.sax.ContentHandler):\n    def __init__(self):\n        xml.sax.ContentHandler.__init__(self)\n\n    def start_element(self, name, attributes):\n        print('start:', name)\n\n    def end_element(self, name):\n        print('end:', name)\n\n    def characters(self, characters):\n        print('characters:', characters)\n\n\ndef not_recommended_apis_compliant():\n    xml_string = \"<body>XML_STRING</body>\"\n\n    # Compliant: avoids using unrecommended APIs.\n    defusedxml.sax.parseString(xml_string, ContentHandler())\n\n\nif __name__ == \"__main__\":\n    not_recommended_apis_compliant()"
            }
        ]
    },
    "insecure-connection": {
        "ruleId": "insecure-connection",
        "version": "1.0",
        "name": "Insecure connection using unencrypted protocol",
        "shortDescription": "Connections that use insecure protocols transmit data in cleartext, which can leak sensitive information.",
        "longDescription": "Connections that use insecure protocols transmit data in cleartext. This introduces a risk of exposing sensitive data to third parties.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "cryptography",
            "information-leak",
            "networking",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-connection@v1.0",
        "cwes": [
            319
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def ftp_connection_noncompliant():\n    import ftplib\n    # Noncompliant: insecure ftp used.\n    cnx = ftplib.FTP(\"ftp://anonymous@example.com\")"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def ftp_connection_compliant():\n    import ftplib\n    # Compliant: secure ftp_tls used.\n    cnx = ftplib.FTP_TLS(\"ftp.example.com\")"
            }
        ]
    },
    "weak-obfuscation-of-request": {
        "ruleId": "weak-obfuscation-of-request",
        "version": "1.0",
        "name": "Weak obfuscation of web request",
        "shortDescription": "Weak obfuscation while configuring a web request.",
        "longDescription": "Weak obfuscation while configuring a web request is vulnerable to unauthorized access. Using stronger obfuscation significantly reduces the chances of attacks due to unauthorized access.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/weak-obfuscation-of-request@v1.0",
        "cwes": [
            522,
            202
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def http_request_noncompliant(username, password, url):\n    import urllib3 as urllib3\n    from base64 import b64encode\n    userpass = \"%s:%s\" % (username, password)\n    # Noncompliant: weak encoding used in HTTP Basic Authentication.\n    authorization = b64encode(str.encode(userpass)).decode(\"utf-8\")\n    headers = {'Authorization': 'Basic %s' % authorization}\n    urllib3.disable_warnings()\n    http = urllib3.PoolManager()\n    response = http.request('GET', url, headers=headers)"
            }
        ]
    },
    "improper-authentication": {
        "ruleId": "improper-authentication",
        "version": "1.0",
        "name": "Improper authentication",
        "shortDescription": "Your code doesn't sufficiently authenticate identities provided by its users.",
        "longDescription": "Failure to verify a user's identity results in improper authentication. This can allow an attacker to acquire privileges to access sensitive data in your application.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/improper-authentication@v1.0",
        "cwes": [
            287,
            521,
            502
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def improper_authentication_noncompliant(token):\n    import jwt\n    # Noncompliant: The verify flag is set to false.\n    jwt.decode(token, verify=False)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def improper_authentication_compliant(token):\n    import jwt\n    # Compliant: The verify flag is set to true.\n    jwt.decode(token, verify=True)"
            }
        ]
    },
    "improper-certificate-validation": {
        "ruleId": "improper-certificate-validation",
        "version": "1.0",
        "name": "Improper certificate validation",
        "shortDescription": "Lack of validation of a security certificate can lead to host impersonation and sensitive data leaks.",
        "longDescription": "Lack of validation or insufficient validation of a security certificate can lead to host impersonation and sensitive data leaks.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "cryptography",
            "owasp-top10"
        ],
        "ruleManifestId": "python/improper-certificate-validation@v1.0",
        "cwes": [
            295
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def create_connection_noncompliant():\n    import socket\n    import ssl\n    host, port = 'example.com', 443\n    with socket.socket(socket.AF_INET) as sock:\n        context = ssl.SSLContext()\n        # Noncompliant: security certificate validation disabled.\n        context.verify_mode = ssl.CERT_NONE\n        conn = context.wrap_socket(sock, server_hostname=host)\n        try:\n            conn.connect((host, port))\n            handle(conn)\n        finally:\n            conn.close()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def create_connection_compliant():\n    import socket\n    import ssl\n    host, port = 'example.com', 443\n    with socket.socket(socket.AF_INET) as sock:\n        context = ssl.SSLContext()\n        # Compliant: security certificate validation enabled.\n        context.verify_mode = ssl.CERT_REQUIRED\n        conn = context.wrap_socket(sock, server_hostname=host)\n        try:\n            conn.connect((host, port))\n            handle(conn)\n        finally:\n            conn.close()"
            }
        ]
    },
    "not-recommended-apis-high": {
        "ruleId": "not-recommended-apis-high",
        "version": "1.0",
        "name": "Usage of an API that is not recommended - High Severity",
        "shortDescription": "APIs that are not recommended were found - High Severity.",
        "longDescription": "APIs that are not recommended were found. This could indicate a deeper problem in the code. High Severity",
        "severity": "High",
        "language": "Python",
        "tags": [
            "security-context"
        ],
        "ruleManifestId": "python/not-recommended-apis-high@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": []
    },
    "aws-insecure-transmission-cdk": {
        "ruleId": "aws-insecure-transmission-cdk",
        "version": "1.0",
        "name": "AWS insecure transmission CDK",
        "shortDescription": "The product transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.",
        "longDescription": "Checks when user transmitting sensitive information, such as passwords, financial data, or personal information, over a network or storing it in a way that is not adequately protected with encryption.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk",
            "efficiency"
        ],
        "ruleManifestId": "python/aws-insecure-transmission-cdk@v1.0",
        "cwes": [
            319
        ],
        "category": "security",
        "snippets": []
    },
    "missing-encryption-of-sensitive-data-cdk": {
        "ruleId": "missing-encryption-of-sensitive-data-cdk",
        "version": "1.0",
        "name": "AWS missing encryption of sensitive data cdk",
        "shortDescription": "Sensitive or critical information is not encrypted before storage or transmission in the product.",
        "longDescription": "Failing to implement robust data encryption undermines the security guarantees of confidentiality, integrity, and accountability provided by effective encryption practices.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk",
            "efficiency"
        ],
        "ruleManifestId": "python/missing-encryption-of-sensitive-data-cdk@v1.0",
        "cwes": [
            311
        ],
        "category": "security",
        "snippets": []
    },
    "code-injection": {
        "ruleId": "code-injection",
        "version": "1.0",
        "name": "Unsanitized input is run as code",
        "shortDescription": "Scripts generated from unsanitized inputs can lead to malicious behavior and inadvertently running code remotely.",
        "longDescription": "Running scripts generated from unsanitized inputs (for example, evaluating expressions that include user-provided strings) can lead to malicious behavior and inadvertently running code remotely.",
        "severity": "Critical",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/code-injection@v1.0",
        "cwes": [
            94
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/')\ndef execute_input_noncompliant():\n    from flask import request\n    module_version = request.args.get(\"module_version\")\n    # Noncompliant: executes unsanitized inputs.\n    exec(\"import urllib%s as urllib\" % module_version)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/')\ndef execute_input_compliant():\n    from flask import request\n    module_version = request.args.get(\"module_version\")\n    # Compliant: executes sanitized inputs.\n    exec(\"import urllib%d as urllib\" % int(module_version))"
            }
        ]
    },
    "missing-authorization-cdk": {
        "ruleId": "missing-authorization-cdk",
        "version": "1.0",
        "name": "Missing Authorization CDK",
        "shortDescription": "Improper Access Control.",
        "longDescription": "The endpoint is potentially accessible to not authorized users. If it contains sensitive information, like log files for example, it may lead to privilege escalation.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk",
            "efficiency"
        ],
        "ruleManifestId": "python/missing-authorization-cdk@v1.0",
        "cwes": [
            285
        ],
        "category": "security",
        "snippets": []
    },
    "multiprocessing-garbage-collection-prevention": {
        "ruleId": "multiprocessing-garbage-collection-prevention",
        "version": "1.0",
        "name": "Garbage collection prevention in multiprocessing",
        "shortDescription": "Passing a parent process object in a child process can prevent its garbage collection.",
        "longDescription": "If an object could be garbage collected in parent process and if you do not to pass it to a child process, there is a possibility of its garbage collection. This can happen even if the child process is alive.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "concurrency",
            "security-context",
            "subprocess"
        ],
        "ruleManifestId": "python/multiprocessing-garbage-collection-prevention@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def garbage_collect_noncompliant(self):\n    from multiprocessing import Pipe\n    pipe = Pipe()\n    try:\n        # Trigger a refresh.\n        self.assertFalse(\n            client._MongoReplicaSetClient__monitor.isAlive())\n\n        client.disconnect()\n        self.assertSoon(\n            lambda: client._MongoReplicaSetClient__monitor.isAlive())\n\n        client.db.collection.find_one()\n    except Exception:\n        traceback.print_exc()\n        pipe.send(True)\n\n\ndef multiprocessing_noncompliant():\n    from multiprocessing import Process, Pipe\n    parent_connection, child_connection = Pipe()\n    # Noncompliant: fails to pass the parent process object to child processes.\n    process = Process(target=garbage_collect_noncompliant)\n    process.start()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def garbage_collect_compliant(self, pipe):\n    try:\n        # Trigger a refresh.\n        self.assertFalse(\n            client._MongoReplicaSetClient__monitor.isAlive())\n\n        client.disconnect()\n        self.assertSoon(\n            lambda: client._MongoReplicaSetClient__monitor.isAlive())\n\n        client.db.collection.find_one()\n    except Exception:\n        traceback.print_exc()\n        pipe.send(True)\n\n\ndef multiprocessing_compliant():\n    from multiprocessing import Process, Pipe\n    parent_connection, child_connection = Pipe()\n    # Compliant: parent process object is passed to its child processes.\n    process = Process(target=garbage_collect_compliant,\n                      args=(child_connection,))\n    process.start()"
            }
        ]
    },
    "xml-external-entity": {
        "ruleId": "xml-external-entity",
        "version": "1.0",
        "name": "XML External Entity",
        "shortDescription": "Objects that parse or handle XML can lead to XML External Entity (XXE) attacks when misconfigured.",
        "longDescription": "Objects that parse or handle XML data can lead to XML External Entity (XXE) attacks when not configured properly. Improper restriction of XML external entity processing can lead to server-side request forgery and information disclosure.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "xml",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/xml-external-entity@v1.0",
        "cwes": [
            611
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def xml_parse_noncompliant():\n    from lxml import etree\n    # Noncompliant: resolve_entities is not disabled\n    # and is set to true by default.\n    parser = etree.XMLParser()\n    tree1 = etree.parse('resources/xxe.xml', parser)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def xml_parse_compliant():\n    from lxml import etree\n    # Compliant: resolve_entities is disabled.\n    parser = etree.XMLParser(resolve_entities=False)\n    tree1 = etree.parse('resources/xxe.xml', parser)"
            }
        ]
    },
    "missing-pagination": {
        "ruleId": "missing-pagination",
        "version": "1.0",
        "name": "Missing pagination",
        "shortDescription": "Missing pagination on a paginated call can lead to inaccurate results.",
        "longDescription": "Missing pagination on a paginated call can lead to inaccurate results. One must paginate to ensure additional results are not present, before returning the results.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "aws-python-sdk",
            "data-integrity",
            "security-context"
        ],
        "ruleManifestId": "python/missing-pagination@v1.0",
        "cwes": [
            19
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def s3_loop_noncompliant(s3bucket_name, s3prefix_name):\n    import boto3\n\n    s3_client = boto3.resource('s3').meta.client\n    # Noncompliant: loops through the contents without checking whether\n    # more requests are needed.\n    list_object_response = s3_client.list_objects_v2(Bucket=s3bucket_name,\n                                                     Prefix=s3prefix_name)\n    try:\n        if 'Contents' in list_object_response:\n            s3_deployment_folders = list_object_response['Contents']\n            return s3_deployment_folders\n\n    except ListException:\n        print(\"List objects in bucket {} with prefix {} \"\n              \"failed with response {}\".format(s3bucket_name,\n                                               s3prefix_name,\n                                               list_object_response))"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def s3_recursion_compliant(self, s3bucket_name, s3prefix_name, token=None):\n    import boto3\n\n    s3_client = boto3.client('s3')\n    list_object_response = s3_client.list_objects_v2(\n        Bucket=s3bucket_name,\n        Prefix=s3prefix_name,\n        ContinuationToken=token\n    ) if token else s3_client.list_objects_v2(Bucket=s3bucket_name,\n                                              Prefix=s3prefix_name)\n\n    s3_deployment_folders = list_object_response['Contents']\n    # Compliant: keeps requesting until no more requests are needed.\n    if not list_object_response['IsTruncated']:\n        return s3_deployment_folders\n\n    next_response = self.s3_recursion_compliant(s3bucket_name, s3prefix_name,\n                                                list_object_response\n                                                ['NextContinuationToken'])\n    s3_deployment_folders += next_response\n\n    return s3_deployment_folders"
            }
        ]
    },
    "improper-wildcard-sanitization": {
        "ruleId": "improper-wildcard-sanitization",
        "version": "1.0",
        "name": "Improper sanitization of wildcards or matching symbols",
        "shortDescription": "Unsanitized wildcards or special matching symbols in user-provided strings can enable attacks and lead to unwanted behavior.",
        "longDescription": "Unsanitized wildcards or special matching symbols in user-provided strings can enable attacks and lead to unwanted behavior, including unwanted filesystem access and denial of service.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection"
        ],
        "ruleManifestId": "python/improper-wildcard-sanitization@v1.0",
        "cwes": [
            155
        ],
        "category": "security",
        "snippets": []
    },
    "lambda-override-reserved": {
        "ruleId": "lambda-override-reserved",
        "version": "1.0",
        "name": "Override of reserved variable names in a Lambda function",
        "shortDescription": "Overriding environment variables that are reserved by AWS Lambda might lead to unexpected behavior.",
        "longDescription": "Overriding environment variables that are reserved by AWS Lambda might lead to unexpected behavior or failure of the Lambda function.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "availability",
            "aws-python-sdk",
            "aws-lambda",
            "data-integrity",
            "maintainability",
            "security-context"
        ],
        "ruleManifestId": "python/lambda-override-reserved@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def create_variable_noncompliant():\n    import os\n    # Noncompliant: overrides reserved environment variable names\n    # in a Lambda function.\n    os.environ['_HANDLER'] = \"value\""
            },
            {
                "type": "COMPLIANT",
                "snippet": "def create_variable_compliant():\n    import os\n    # Compliant: prevents overriding reserved environment variable names\n    # in a Lambda function.\n    os.environ['SOME_ENV_VAR'] = \"value\""
            }
        ]
    },
    "loose-file-permissions": {
        "ruleId": "loose-file-permissions",
        "version": "1.0",
        "name": "Loose file permissions",
        "shortDescription": "Weak file permissions can lead to privilege escalation.",
        "longDescription": "File and directory permissions should be granted to specific users and groups. Granting permissions to wildcards, such as everyone or others, can lead to privilege escalations, leakage of sensitive information, and inadvertently running malicious code.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "information-leak",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/loose-file-permissions@v1.0",
        "cwes": [
            732,
            266
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def change_file_permissions_noncompliant():\n    import os\n    import stat\n    # Noncompliant: permissions assigned to all users.\n    os.chmod(\"sample.txt\", stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def change_file_permissions_compliant():\n    import os\n    import stat\n    # Compliant: permissions assigned to owner and owner group.\n    os.chmod(\"sample.txt\", stat.S_IRWXU | stat.S_IRWXG)"
            }
        ]
    },
    "insecure-temp-file": {
        "ruleId": "insecure-temp-file",
        "version": "1.0",
        "name": "Insecure temporary file or directory",
        "shortDescription": "Insecure ways of creating temporary files and directories can lead to race conditions, privilege escalation, and other security vulnerabilities.",
        "longDescription": "Insecure ways of creating temporary files and directories can lead to race conditions (which can be exploited for denial of service attacks) and other security vulnerabilities such as privilege escalation.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "availability",
            "race-condition",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-temp-file@v1.0",
        "cwes": [
            377
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def create_file_noncompliant(results):\n    import tempfile\n    # Noncompliant: uses a temporary file path to create a temporary file.\n    filename = tempfile.mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def create_temp_file_compliant(results):\n    import tempfile\n    # Compliant: uses the correct mechanism to create a temporary file.\n    with tempfile.NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)"
            }
        ]
    },
    "do-not-auto-add-or-warning-missing-hostkey-policy": {
        "ruleId": "do-not-auto-add-or-warning-missing-hostkey-policy",
        "version": "1.0",
        "name": "Using AutoAddPolicy or WarningPolicy",
        "shortDescription": "Using `AutoAddPolicy` or `WarningPolicy` can allow a malicious server to impersonate a trusted server.",
        "longDescription": "We detected a Paramiko host key policy that implicitly trusts server's host key. Do not use `AutoAddPolicy` or `WarningPolicy` as a missing host key policy when creating `SSHClient`. Unverified host keys can allow a malicious server to take control of a trusted server by using the sensitive data (such as authentication information). Instead, use `RejectPolicy` or a custom subclass.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "owasp-top10"
        ],
        "ruleManifestId": "python/do-not-auto-add-or-warning-missing-hostkey-policy@v1.0",
        "cwes": [
            322
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def do_not_auto_add_or_warning_missing_hostkey_policy_noncompliant():\n    from paramiko import AutoAddPolicy\n    from paramiko.client import SSHClient\n    ssh_client = SSHClient()\n    # Noncompliant: Insecure `AutoAddPolicy` is used as missing hostkey policy.\n    ssh_client.set_missing_host_key_policy(policy=AutoAddPolicy)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def do_not_auto_add_or_warning_missing_hostkey_policy_compliant():\n    from paramiko import RejectPolicy\n    from paramiko.client import SSHClient\n    ssh_client = SSHClient()\n    # Compliant: Secure `RejectPolicy` is used as missing hostkey policy.\n    ssh_client.set_missing_host_key_policy(RejectPolicy)"
            }
        ]
    },
    "aws-kmskey-encryption-cdk": {
        "ruleId": "aws-kmskey-encryption-cdk",
        "version": "1.0",
        "name": "aws kmskey encryption cdk",
        "shortDescription": "Using an AWS KMS key helps follow the standard security advice of granting least privilege to objects generated by the project.",
        "longDescription": "Using AWS KMS keys enables the organization to align with the standard security advice of granting least privilege. The data stored in the S3 bucket remains protected through encryption, and access to both the data and the encryption keys is restricted to authorized entities, reducing the potential security risks associated with data exposure and unauthorized access.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk",
            "efficiency"
        ],
        "ruleManifestId": "python/aws-kmskey-encryption-cdk@v1.0",
        "cwes": [
            311
        ],
        "category": "security",
        "snippets": []
    },
    "ldap-authentication": {
        "ruleId": "ldap-authentication",
        "version": "1.0",
        "name": "Unauthenticated LDAP requests",
        "shortDescription": "Unauthenticated LDAP requests can allow untrusted access to LDAP servers.",
        "longDescription": "Do not use anonymous or unauthenticated authentication mechanisms with a blind LDAP client request because they allow unauthorized access without passwords.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "ldap",
            "owasp-top10"
        ],
        "ruleManifestId": "python/ldap-authentication@v1.0",
        "cwes": [
            521
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def authenticate_connection_noncompliant():\n    import ldap\n    import os\n    connect = ldap.initialize('ldap://127.0.0.1:1389')\n    connect.set_option(ldap.OPT_REFERRALS, 0)\n    # Noncompliant: authentication disabled.\n    connect.simple_bind('cn=root')"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def authenticate_connection_compliant():\n    import ldap\n    import os\n    connect = ldap.initialize('ldap://127.0.0.1:1389')\n    connect.set_option(ldap.OPT_REFERRALS, 0)\n    # Compliant: simple security authentication used.\n    connect.simple_bind('cn=root', os.environ.get('LDAP_PASSWORD'))"
            }
        ]
    },
    "docker-arbitrary-container-run": {
        "ruleId": "docker-arbitrary-container-run",
        "version": "1.0",
        "name": "Docker arbitrary container run",
        "shortDescription": "Passing an unsanitized user argument to a function call makes your code insecure.",
        "longDescription": "You are not sanitizing user input that is used as an argument for the Docker image. We recommend that you sanitize user input before passing it to a function call.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/docker-arbitrary-container-run@v1.0",
        "cwes": [
            77
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "@app.route('/someUrl')\ndef docker_arbitrary_container_run_noncompliant():\n    client = docker.from_env()\n    img = request.args.get(\"image\")\n    # Noncompliant: Unsanitised user input is passed to `run`.\n    client.containers.run(img, 'echo non compliant')"
            },
            {
                "type": "COMPLIANT",
                "snippet": "@app.route('/someUrl')\ndef docker_arbitrary_container_run_compliant():\n    client = docker.from_env()\n    img = os.environ[\"image\"]\n    # Compliant: Input from environment variable is passed to `run`.\n    client.containers.run(img, 'echo hello world')"
            }
        ]
    },
    "insecure-socket-bind": {
        "ruleId": "insecure-socket-bind",
        "version": "1.0",
        "name": "Insecure Socket Bind",
        "shortDescription": "Binding the socket with an empty IP address can introduce security risks.",
        "longDescription": "Binding the socket with an empty IP address will allow it to accept connections from any IPv4 address provided, thus can introduce security risks.",
        "severity": "Critical",
        "language": "Python",
        "tags": [
            "information-leak",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/insecure-socket-bind@v1.0",
        "cwes": [
            200
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def insecure_socket_bind_noncompliant():\n    import socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # Noncompliant: Empty IP Address is passed when binding to a socket.\n    s.bind(('', 0))"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def insecure_socket_bind_compliant():\n    import socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # Compliant: Non-empty IP Address is passed when binding to a socket.\n    s.bind(('192.168.1.1', 0))"
            }
        ]
    },
    "untrusted-ami-images": {
        "ruleId": "untrusted-ami-images",
        "version": "1.0",
        "name": "Untrusted AMI images",
        "shortDescription": "Improper filtering of Amazon Machine Images (AMIs) can result in loading an untrusted image, a potential security vulnerability.",
        "longDescription": "The code requests Amazon Machine Images (AMIs) by name, without filtering them by owner or AMI identifiers. The response might contain untrusted public images from other accounts. Launching an AMI from an untrusted source might inadvertently run malicious code.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "amazon-ec2",
            "aws-python-sdk",
            "injection"
        ],
        "ruleManifestId": "python/untrusted-ami-images@v1.0",
        "cwes": [
            349
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def image_filter_non_compliant():\n    import boto3\n    ec2 = boto3.resource('ec2')\n    image_name = 'The name of the AMI (provided during image creation)'\n    # Noncompliant: requests Amazon Machine Images (AMIs) with\n    # only name filter ignoring owner or AMI identifiers.\n    filters = [{'Name': 'name', 'Values': [image_name]}]\n    images = ec2.images.filter(Filters=filters)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def image_filter_compliant():\n    import boto3\n    ec2 = boto3.resource('ec2')\n    image_name = 'The name of the AMI (provided during image creation)'\n    owner_id = 'The AWS account ID of the owner'\n    # Compliant: requests Amazon Machine Images (AMIs) with\n    # both name and owner-id filters.\n    filters = [\n        {'Name': 'name', 'Values': [image_name]},\n        {'Name': 'owner-id', 'Values': [owner_id]}\n    ]\n    images = ec2.images.filter(Filters=filters)"
            }
        ]
    },
    "insecure-hashing": {
        "ruleId": "insecure-hashing",
        "version": "1.0",
        "name": "Insecure hashing",
        "shortDescription": "Obsolete, broken, or weak hashing algorithms can lead to security vulnerabilities.",
        "longDescription": "A hashing algorithm is weak if it is easy to determine the original input from the hash or to find another input that yields the same hash. Weak hashing algorithms can lead to security vulnerabilities.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "cryptography",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-hashing@v1.0",
        "cwes": [
            327,
            328
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def hashing_noncompliant():\n    import hashlib\n    from hashlib import pbkdf2_hmac\n    # Noncompliant: insecure hashing algorithm used.\n    derivedkey = hashlib.pbkdf2_hmac('sha224', password, salt, 100000)\n    derivedkey.hex()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def hashing_compliant():\n    import hashlib\n    from hashlib import pbkdf2_hmac\n    # Compliant: secure hashing algorithm used.\n    derivedkey = hashlib.pbkdf2_hmac('sha256', password, salt, 100000)\n    derivedkey.hex()"
            }
        ]
    },
    "sensitive-information-leak": {
        "ruleId": "sensitive-information-leak",
        "version": "1.0",
        "name": "Sensitive information leak",
        "shortDescription": "Exposure of sensitive information can lead to an unauthorized actor having access to the information.",
        "longDescription": "This code might expose sensitive information to an actor who is not explicitly authorized to have access to the information. This could have serious consequences depending on the type of information revealed and how attackers can use the information.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "information-leak",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/sensitive-information-leak@v1.0",
        "cwes": [
            200
        ],
        "category": "security",
        "snippets": []
    },
    "cross-site-scripting": {
        "ruleId": "cross-site-scripting",
        "version": "1.0",
        "name": "Cross-site scripting",
        "shortDescription": "Relying on potentially untrusted user inputs when constructing web application outputs can lead to cross-site scripting vulnerabilities.",
        "longDescription": "User-controllable input must be sanitized before it's included in output used to dynamically generate a web page. Unsanitized user input can introduce cross-side scripting (XSS) vulnerabilities that can lead to inadvertedly running malicious code in a trusted context.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/cross-site-scripting@v1.0",
        "cwes": [
            20,
            79,
            80
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/redirect')\ndef redirect_url_noncompliant():\n    from flask import request, redirect\n    endpoint = request.args['url']\n    # Noncompliant: redirect to a user-supplied URL without sanitization.\n    return redirect(endpoint)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/redirect')\ndef redirect_url_compliant():\n    from flask import request, url_for, redirect\n    endpoint = request.args['url']\n    # Compliant: user-supplied URL is sanitized before redirecting to it.\n    return redirect(url_for(endpoint))"
            }
        ]
    },
    "missing-authorization": {
        "ruleId": "missing-authorization",
        "version": "1.0",
        "name": "Missing authorization",
        "shortDescription": "Missing authorization checks can lead to unauthorized access to a resource or performance of an action.",
        "longDescription": "We recommend that you apply access control checks to all access points. When access control checks are not applied, users are able to access data or perform actions that they should not be allowed to access or perform. The lack of access control checks can cause the exposure of information, denial of service, and arbitrary code execution.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/missing-authorization@v1.0",
        "cwes": [
            862
        ],
        "category": "security",
        "snippets": []
    },
    "api-logging-disabled-cdk": {
        "ruleId": "api-logging-disabled-cdk",
        "version": "1.0",
        "name": "AWS api logging disabled cdk",
        "shortDescription": "Api Logging Disabled may lead to unable to access log and does not record the event.",
        "longDescription": "When an API does not have access logging enabled, it means that the system or organization responsible for the API is missing out on valuable information about how the API is being used, and it is failing to capture important data that can be essential for various purposes.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "amazon-s3",
            "aws-cdk",
            "efficiency"
        ],
        "ruleManifestId": "python/api-logging-disabled-cdk@v1.0",
        "cwes": [
            778
        ],
        "category": "security",
        "snippets": []
    },
    "aws-kms-reencryption": {
        "ruleId": "aws-kms-reencryption",
        "version": "1.0",
        "name": "Client-side KMS reencryption",
        "shortDescription": "Client-side decryption followed by reencryption is inefficient and can lead to sensitive data leaks.",
        "longDescription": "Client-side decryption followed by reencryption is inefficient and can lead to sensitive data leaks. The `reencrypt` APIs allow decryption followed by reencryption on the server side. This is more efficient and secure.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "aws-python-sdk",
            "aws-kms"
        ],
        "ruleManifestId": "python/aws-kms-reencryption@v1.0",
        "cwes": [
            310,
            311
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def kms_reencrypt_noncompliant():\n    import boto3\n    import base64\n    client = boto3.client('kms')\n    plaintext = client.decrypt(\n        CiphertextBlob=bytes(base64.b64decode(\"secret\"))\n    )\n    # Noncompliant: decrypt is immediately followed by encrypt.\n    response = client.encrypt(\n        KeyId='string',\n        Plaintext=plaintext\n    )\n    return response"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def kms_reencrypt_compliant():\n    import boto3\n    import base64\n    client = boto3.client('kms')\n    # Compliant: server-side reencryption.\n    response = client.re_encrypt(\n        CiphertextBlob=bytes(base64.b64decode(\"secret\")),\n        DestinationKeyId=\"string\",\n    )\n    return response"
            }
        ]
    },
    "improper-privilege-management": {
        "ruleId": "improper-privilege-management",
        "version": "1.0",
        "name": "Improper privilege management",
        "shortDescription": "Privilege escalation happens when a malicious user gains elevated access to resources that should be unavailable to them.",
        "longDescription": "Privilege escalation occurs when a malicious user exploits a bug, design flaw, or configuration error in an application or operating system to gain elevated access to the system. Elevated privileges can be used to delete files, view private information, or install unwanted programs or backdoors.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/improper-privilege-management@v1.0",
        "cwes": [
            269
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def set_user_noncompliant():\n    import os\n    root = 0\n    # Noncompliant: the process user is set to root.\n    os.setuid(root)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def set_user_compliant():\n    import os\n    root = 4\n    # Compliant: the process user is set to userid 4.\n    os.setuid(root)"
            }
        ]
    },
    "integer-overflow": {
        "ruleId": "integer-overflow",
        "version": "1.0",
        "name": "Integer overflow",
        "shortDescription": "An integer overflow might might cause security issues when it is used for resource management or execution control.",
        "longDescription": "An integer overflow might occur when the input or resulting value is too large to store in associated representation. This can result in a critical security issue when it is used to make security decisions.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "security-context",
            "top25-cwes"
        ],
        "ruleManifestId": "python/integer-overflow@v1.0",
        "cwes": [
            190
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "\n\ndef integer_overflow_noncompliant():\n    # Noncompliant: Number larger than limit of the datatype is stored.\n    arr = np.array([[100000000]], dtype=np.int8)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def integer_overflow_compliant(self, request_items):\n    # Compliant: Number stored is within the limits of the specified datatype.\n    arr = np.array([100000000], dtype=np.int32)"
            }
        ]
    },
    "ldap-injection": {
        "ruleId": "ldap-injection",
        "version": "1.0",
        "name": "LDAP injection",
        "shortDescription": "LDAP queries that rely on potentially untrusted inputs can allow attackers to read or modify sensitive data, run code, and perform other unwanted actions.",
        "longDescription": "An LDAP query that relies on potentially untrusted inputs might allow attackers to inject unwanted elements into the query. This can allow attackers to read or modify sensitive data, run code, and perform other unwanted actions.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "ldap",
            "owasp-top10"
        ],
        "ruleManifestId": "python/ldap-injection@v1.0",
        "cwes": [
            90
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/getUsers')\ndef get_users_noncompliant():\n    import ldap\n    from flask import request\n    username = request.args['username']\n    filter_string = '(uid=' + username + ')'\n    ldap_conn = ldap.initialize('ldaps://ldap.amazon.com:636')\n    # Noncompliant: user-supplied filter is not sanitized.\n    result = ldap_conn.search_s('o=amazon.com',\n                                ldap.SCOPE_SUBTREE,\n                                filter_string)\n    return result"
            },
            {
                "type": "COMPLIANT",
                "snippet": "from flask import app\n\n\n@app.route('/getUsers')\ndef get_users_compliant(request):\n    import ldap\n    import re\n    from flask import request\n    username = request.args['username']\n    # Compliant: user-supplied filter is checked for allowed characters.\n    filter_string = \"(uid=\" + re.sub('[!@#$%^&*()_+-=]', '', username) + \")\"\n    ldap_conn = ldap.initialize('ldaps://ldap.amazon.com:636')\n    result = ldap_conn.search('o=amazon.com',\n                              ldap.SCOPE_SUBTREE,\n                              filter_string)\n    return result"
            }
        ]
    },
    "hardcoded-bind-all-interfaces": {
        "ruleId": "hardcoded-bind-all-interfaces",
        "version": "1.0",
        "name": "Hardcoded interface binding",
        "shortDescription": "Binding to all network interfaces can open a service up  to traffic on interfaces that are not properly documented or secured.",
        "longDescription": "Binding to all network interfaces can open a service up to  traffic on interfaces that are not properly documented or secured. To ensure  that connections from anywhere are not accepted, don't bind to '0.0.0.0'  using a hardcoded reference.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "availability",
            "networking"
        ],
        "ruleManifestId": "python/hardcoded-bind-all-interfaces@v1.0",
        "cwes": [
            605
        ],
        "category": "security",
        "snippets": []
    },
    "untrusted-deserialization": {
        "ruleId": "untrusted-deserialization",
        "version": "1.0",
        "name": "Deserialization of untrusted object",
        "shortDescription": "Deserialization of untrusted objects can lead to security vulnerabilities such as inadvertently running remote code.",
        "longDescription": "Deserialization of untrusted or potentially malformed data can be exploited for denial of service or to induce running untrusted code.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "deserialization",
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/untrusted-deserialization@v1.0",
        "cwes": [
            502
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def untrusted_deserialization_noncompliant():\n    import jsonpickle\n    userobj = input(\"user\")\n    # Noncompliant: Untrusted object deserialized without validation.\n    obj = jsonpickle.decode(userobj)\n    return obj"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def untrusted_deserialization_compliant():\n    import jsonpickle\n    userobj = input(\"user\")\n    allowed_user_obj = ['example_module1', 'example_module2']\n    # Compliant: Untrusted object is validated before deserialization.\n    if userobj in allowed_user_obj:\n        obj = jsonpickle.decode(userobj)\n        return obj"
            }
        ]
    },
    "zip-bomb-attack": {
        "ruleId": "zip-bomb-attack",
        "version": "1.0",
        "name": "Zip bomb attack",
        "shortDescription": "Expanding unsanitized archive files taken as input can lead to zip bomb attacks.",
        "longDescription": "Expanding input archive files without any validation could make your code vulnerable to zip bomb attacks, which could potentially cause denial of service (DoS). We recommend that you sanitize input archive files before extracting them.",
        "severity": "High",
        "language": "Python",
        "tags": [],
        "ruleManifestId": "python/zip-bomb-attack@v1.0",
        "cwes": [
            409
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "@app.route('/someUrl')\ndef zip_bomb_attack_noncompliant():\n    file = request.files['file']\n    filename = file.filename\n    file.save(filename)\n    tfile = tarfile.open(filename)\n    # Noncompliant: Untrusted archive file extracted without any validation.\n    tfile.extractall('./tmp/')\n    tfile.close()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "@app.route('/someUrl')\ndef zip_bomb_attack_compliant():\n    file = request.files['file']\n    filename = file.filename\n    file.save(filename)\n    tfile = tarfile.open(filename)\n    threshold_entries = 100  # some threshold value\n    # Compliant: Untrusted archive file is validated before extraction.\n    if len(tfile.getmembers()) < threshold_entries:\n        tfile.extractall('./tmp/')\n    tfile.close()"
            }
        ]
    },
    "hardcoded-ip-address": {
        "ruleId": "hardcoded-ip-address",
        "version": "1.0",
        "name": "Hardcoded IP address",
        "shortDescription": "Hardcoding an IP address can cause security problems.",
        "longDescription": "We recommend that you do not hardcode IP addresses because they might change. A hardcoded IP address can make your code vulnerable to denial of service attacks and IP address spoofing to bypass security checks.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "networking",
            "security-context"
        ],
        "ruleManifestId": "python/hardcoded-ip-address@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def hardcoded_ip_address_noncompliant():\n    sock = socket(AF_INET, SOCK_STREAM)\n    # Noncompliant: IP address is hardcoded.\n    sock.bind(('193.168.14.31', 80))"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def hardcoded_ip_address_compliant(ip_add=None):\n    sock = socket(AF_INET, SOCK_STREAM)\n    # Compliant: IP address is not hardcoded.\n    sock.bind((ip_add, 5080))"
            }
        ]
    },
    "cross-site-request-forgery": {
        "ruleId": "cross-site-request-forgery",
        "version": "1.0",
        "name": "Cross-site request forgery",
        "shortDescription": "Insecure configuration can lead to a cross-site request forgery (CRSF) vulnerability.",
        "longDescription": "Insecure configuration can lead to a cross-site request forgery (CRSF) vulnerability. This can enable an attacker to trick end users into performing unwanted actions while authenticated.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "configuration",
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/cross-site-request-forgery@v1.0",
        "cwes": [
            352
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def csrf_protection_noncompliant():\n    from flask import Flask\n    app = Flask(__name__)\n    # Noncompliant: disables CSRF protection.\n    app.config['WTF_CSRF_ENABLED'] = False"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def csrf_protection_compliant():\n    from flask_wtf.csrf import CsrfProtect\n    from flask import Flask\n    csrf = CsrfProtect()\n    app = Flask(__name__)\n    # Compliant: enables CSRF protection.\n    csrf.init_app(app)"
            }
        ]
    },
    "insecure-cookie": {
        "ruleId": "insecure-cookie",
        "version": "1.0",
        "name": "Insecure cookie",
        "shortDescription": "Insecure cookies can lead to unencrypted transmission of sensitive data.",
        "longDescription": "Insecure cookie settings can lead to unencrypted cookie transmission. Even if a cookie doesn't contain sensitive data now, it could be added later. It's good practice to transmit all cookies only through secure channels.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "cookies",
            "cryptography",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-cookie@v1.0",
        "cwes": [
            614,
            311,
            312
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def secure_cookie_noncompliant():\n    from http.cookies import SimpleCookie\n    cookie = SimpleCookie()\n    cookie['sample'] = \"sample_value\"\n    # Noncompliant: the cookie is insecure.\n    cookie['sample']['secure'] = 0\n    print(cookie)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def secure_cookie_compliant():\n    from http.cookies import SimpleCookie\n    cookie = SimpleCookie()\n    cookie['sample'] = \"sample_value\"\n    # Compliant: the cookie is secure.\n    cookie['sample']['secure'] = True  # compliant\n    print(cookie)"
            }
        ]
    },
    "sql-injection": {
        "ruleId": "sql-injection",
        "version": "1.0",
        "name": "SQL injection",
        "shortDescription": "Use of untrusted inputs in a SQL database query can enable attackers to read, modify, or delete sensitive data in the database",
        "longDescription": "User-provided inputs must be sanitized before being used to generate a SQL database query. An attacker can create and use untrusted input to run query statements that read, modify, or delete database content.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "sql",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/sql-injection@v1.0",
        "cwes": [
            89
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def execute_query_noncompliant(request):\n    import sqlite3\n    name = request.GET.get(\"name\")\n    query = \"SELECT * FROM Users WHERE name = \" + name + \";\"\n    with sqlite3.connect(\"example.db\") as connection:\n        cursor = connection.cursor()\n        # Noncompliant: user input is used without sanitization.\n        cursor.execute(query)\n        connection.commit()\n        connection.close()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def execute_query_compliant(request):\n    import re\n    import sqlite3\n    name = request.GET.get(\"name\")\n    query = \"SELECT * FROM Users WHERE name = \"\n    + re.sub('[^a-zA-Z]+', '', name) + \";\"\n    with sqlite3.connect(\"example.db\") as connection:\n        cursor = connection.cursor()\n        # Compliant: user input is sanitized before use.\n        cursor.execute(query)\n        connection.commit()\n        connection.close()"
            }
        ]
    },
    "server-side-request-forgery": {
        "ruleId": "server-side-request-forgery",
        "version": "1.0",
        "name": "Server-side request forgery",
        "shortDescription": "Insufficient sanitization of potentially untrusted URLs on the server side can allow server requests to unwanted destinations.",
        "longDescription": "Insufficient sanitization of potentially untrusted URLs on the server side can lead to the server issuing requests to unwanted hosts, ports, or protocols, which can bypass proxies, firewalls, and other security measures.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "configuration",
            "injection",
            "networking",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/server-side-request-forgery@v1.0",
        "cwes": [
            918
        ],
        "category": "security",
        "snippets": []
    },
    "partial-encryption": {
        "ruleId": "partial-encryption",
        "version": "1.0",
        "name": "Sensitive data stored unencrypted due to partial encryption",
        "shortDescription": "Encryption that is dependent on conditional logic, such as an `if...then` clause, might cause unencrypted sensitive data to be stored.",
        "longDescription": "Encryption that is dependent on conditional logic, such as an `if...then` clause, might cause unencrypted sensitive data to be stored. If data is encrypted along some branch of a conditional statement, then encrypt data along all branches.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "aws-python-sdk",
            "cryptography",
            "information-leak",
            "owasp-top10"
        ],
        "ruleManifestId": "python/partial-encryption@v1.0",
        "cwes": [
            311
        ],
        "category": "security",
        "snippets": []
    },
    "insecure-hashing-hashlib": {
        "ruleId": "insecure-hashing-hashlib",
        "version": "1.0",
        "name": "Weak algorithm used for Password Hashing",
        "shortDescription": "Weak algorithm used for Password Hashing. Consider using stronger algorithms, such as Argon2, PBKDF2, or scrypt.",
        "longDescription": "Weak algorithm used for Password Hashing. Consider using stronger algorithms, such as Argon2, PBKDF2, or scrypt.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "cryptography",
            "owasp-top10"
        ],
        "ruleManifestId": "python/insecure-hashing-hashlib@v1.0",
        "cwes": [
            327,
            328
        ],
        "category": "security",
        "snippets": []
    },
    "improper-input-validation": {
        "ruleId": "improper-input-validation",
        "version": "1.0",
        "name": "Improper input validation",
        "shortDescription": "Improper input validation can enable attacks and lead to unwanted behavior.",
        "longDescription": "Improper input validation can enable attacks and lead to unwanted behavior.   Parts of the system may receive unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/improper-input-validation@v1.0",
        "cwes": [
            20
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def yaml_load_noncompliant():\n    import json\n    import yaml\n    response = yaml.dump({'a': 1, 'b': 2, 'c': 3})\n    # Noncompliant: uses unsafe yaml load.\n    result = yaml.load(response)\n    yaml.dump(result)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def yaml_load_compliant():\n    import json\n    import yaml\n    response = yaml.dump({'a': 1, 'b': 2, 'c': 3})\n    # Compliant: uses safe yaml load.\n    result = yaml.load(response, Loader=yaml.CSafeLoader)\n    yaml.dump(result)"
            }
        ]
    },
    "module-injection": {
        "ruleId": "module-injection",
        "version": "1.0",
        "name": "Module injection",
        "shortDescription": "Untrusted user imports in the `importlib.import_module()` function allow attacks.",
        "longDescription": "Untrusted user imports in Python allow an attacker to load arbitrary code. To prevent malicious code from running, only allow imports from trusted libraries or from libraries on allow lists.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10"
        ],
        "ruleManifestId": "python/module-injection@v1.0",
        "cwes": [
            706
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def module_injection_noncompliant():\n    import importlib\n    module_name = input('module name')\n    # Noncompliant: Untrusted user input is being passed to `import_module`.\n    importlib.import_module(module_name)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def module_injection_compliant():\n    import importlib\n    allowed_module_names_list = ['example_module1', 'example_module2']\n    module_name = input('module name')\n    if module_name in allowed_module_names_list:\n        # Compliant: User input is validated before using in `import_module()`.\n        importlib.import_module(module_name)"
            }
        ]
    },
    "not-recommended-apis-medium": {
        "ruleId": "not-recommended-apis-medium",
        "version": "1.0",
        "name": "Usage of an API that is not recommended - Medium Severity",
        "shortDescription": "APIs that are not recommended were found - Medium Severity.",
        "longDescription": "APIs that are not recommended were found. This could indicate a deeper problem in the code - Medium Severity.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "security-context"
        ],
        "ruleManifestId": "python/not-recommended-apis-medium@v1.0",
        "cwes": null,
        "category": "security",
        "snippets": []
    },
    "aws-logged-credentials": {
        "ruleId": "aws-logged-credentials",
        "version": "1.0",
        "name": "AWS credentials logged",
        "shortDescription": "Logging unencrypted AWS credentials can expose them to an attacker.",
        "longDescription": "Unencrypted AWS credentials are logged. This could expose those credentials to an attacker. Encrypt sensitive data, such as credentials, before they are logged to make the code more secure.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "aws-python-sdk",
            "secrets",
            "owasp-top10"
        ],
        "ruleManifestId": "python/aws-logged-credentials@v1.0",
        "cwes": [
            255
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def log_credentials_noncompliant():\n    import boto3\n    import logging\n    session = boto3.Session()\n    credentials = session.get_credentials()\n    credentials = credentials.get_frozen_credentials()\n    access_key = credentials.access_key\n    secret_key = credentials.secret_key\n    # Noncompliant: credentials are written to the logger.\n    logging.info('Access key: ', access_key)\n    logging.info('secret access key: ', secret_key)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def log_credentials_compliant():\n    import boto3\n    session = boto3.Session()\n    credentials = session.get_credentials()\n    credentials = credentials.get_frozen_credentials()\n    access_key = credentials.access_key\n    secret_key = credentials.secret_key\n    # Compliant: avoids writing credentials to the logger.\n    session = boto3.Session(\n        aws_access_key_id=access_key,\n        aws_secret_access_key=secret_key\n    )"
            }
        ]
    },
    "os-command-injection": {
        "ruleId": "os-command-injection",
        "version": "1.0",
        "name": "OS command injection",
        "shortDescription": "Constructing operating system or shell commands with unsanitized user input can lead to inadvertently running malicious code.",
        "longDescription": "Constructing operating system or shell commands with unsanitized user input can lead to inadvertently running malicious code.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "subprocess",
            "owasp-top10",
            "top25-cwes"
        ],
        "ruleManifestId": "python/os-command-injection@v1.0",
        "cwes": [
            77,
            78,
            88
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def exec_command_noncompliant():\n    from paramiko import client\n    from flask import request\n    address = request.args.get(\"address\")\n    cmd = \"ping -c 1 %s\" % address\n    client = client.SSHClient()\n    client.connect(\"ssh.samplehost.com\")\n    # Noncompliant: address argument is not sanitized.\n    client.exec_command(cmd)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def exec_command_compliant():\n    from paramiko import client\n    from flask import request\n    address = request.args.get(\"address\")\n    # Compliant: address argument is sanitized (shell-escaped).\n    address = shlex.quote(request.args.get(\"address\"))\n    cmd = \"ping -c 1 %s\" % address\n    client = client.SSHClient()\n    client.connect(\"ssh.samplehost.com\")\n    client.exec_command(cmd)"
            }
        ]
    },
    "xpath-injection": {
        "ruleId": "xpath-injection",
        "version": "1.0",
        "name": "XPath injection",
        "shortDescription": "Potentially unsanitized user input in XPath queries can allow an attacker to control the query in unwanted or insecure ways.",
        "longDescription": "Potentially unsanitized user input in XPath queries can allow an attacker to control the query in unwanted or insecure ways. This might grant the attacker access to any data, not just the data that the original query intended.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "xml",
            "owasp-top10"
        ],
        "ruleManifestId": "python/xpath-injection@v1.0",
        "cwes": [
            643
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "from flask import request, app\n\n\n@app.route('/user')\ndef find_users_noncompliant():\n    from flask import request\n    import xml.etree.ElementTree as ET\n    tree = ET.parse('users.xml')\n    root = tree.getroot()\n    username = request.args['username']\n    query = \"./users/user/[@name='\"+username+\"']/location\"\n    # Noncompliant: evaluating expression built from user-supplied parameter\n    # can lead to XPath injection.\n    elements = root.findall(query)\n    return 'Location %s' % list(elements)"
            },
            {
                "type": "COMPLIANT",
                "snippet": "from flask import request, app\n\n\n@app.route('/user')\ndef find_users_compliant():\n    from flask import request\n    from lxml import etree\n    # Compliant: disabling external entities prevents XPath injection.\n    parser = etree.XMLParser(resolve_entities=False)\n    tree = etree.parse('users.xml', parser)\n    root = tree.getroot()\n    username = request.args['username']\n    query = \"/collection/users/user[@name = $parameter_name]/location/text()\"\n    elements = root.xpath(query, parameter_name=username)\n    return 'Location %s' % list(elements)"
            }
        ]
    },
    "clear-text-credentials": {
        "ruleId": "clear-text-credentials",
        "version": "1.0",
        "name": "Clear text credentials",
        "shortDescription": "Credentials that are stored in clear text can be intercepted by a malicious actor.",
        "longDescription": "Credentials that are stored in clear text in memory or written to log files can be intercepted by a malicious actor.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "access-control",
            "information-leak",
            "secrets",
            "owasp-top10"
        ],
        "ruleManifestId": "python/clear-text-credentials@v1.0",
        "cwes": [
            916,
            328
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "PASSWORD_HASHERS = [\n        # Noncompliant: uses non-standard or insecure password hashers.\n        \"django.contrib.auth.hashers.MD5PasswordHasher\",\n        \"django.contrib.auth.hashers.PBKDF2PasswordHasher\"\n    ]"
            },
            {
                "type": "COMPLIANT",
                "snippet": "PASSWORD_HASHERS = [\n    # Compliant: uses standard and secure hashers.\n    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',\n    'django.contrib.auth.hashers.BCryptPasswordHasher',\n    'django.contrib.auth.hashers.PBKDF2PasswordHasher',\n    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',\n    'django.contrib.auth.hashers.Argon2PasswordHasher'\n]"
            }
        ]
    },
    "resource-leak": {
        "ruleId": "resource-leak",
        "version": "1.0",
        "name": "Resource leak",
        "shortDescription": "Allocated resources are not released properly.",
        "longDescription": "Allocated resources are not released properly. This can slow down or crash your system. They must be closed along all paths to prevent a resource leak.",
        "severity": "Medium",
        "language": "Python",
        "tags": [
            "availability",
            "resource-leak",
            "top25-cwes"
        ],
        "ruleManifestId": "python/resource-leak@v1.0",
        "cwes": [
            400,
            664
        ],
        "category": "security",
        "snippets": [
            {
                "type": "NON_COMPLIANT",
                "snippet": "def read_file_noncompliant(filename):\n    file = open(filename, 'r')\n    # Noncompliant: method returns without properly closing the file.\n    return file.readlines()"
            },
            {
                "type": "COMPLIANT",
                "snippet": "def read_file_compliant(filename):\n    # Compliant: file is declared using a `with` statement.\n    with open(filename, 'r') as file:\n        return file.readlines()"
            }
        ]
    },
    "file-injection": {
        "ruleId": "file-injection",
        "version": "1.0",
        "name": "File injection",
        "shortDescription": "Writing unsanitized user data to a file is unsafe.",
        "longDescription": "Writing unsanitized user data to a file could allow injection or distributed denial of service (DDoS) attacks. Use appropriate sanitizers or validators on the user data before writing the data to a file.",
        "severity": "High",
        "language": "Python",
        "tags": [
            "injection",
            "owasp-top10"
        ],
        "ruleManifestId": "python/file-injection@v1.0",
        "cwes": [
            93,
            1236
        ],
        "category": "security",
        "snippets": []
    }
}